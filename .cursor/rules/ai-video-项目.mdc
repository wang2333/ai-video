---
description: 'AI Video 项目特定开发指导与架构规范'
---

# AI Video 项目开发指导

## 项目领域特定架构

### 核心功能模块划分

```
src/
├── components/
│   ├── video/              # 视频相关组件
│   │   ├── VideoPlayer.tsx     # 视频播放器
│   │   ├── VideoUploader.tsx   # 视频上传组件
│   │   ├── VideoEditor.tsx     # 视频编辑器
│   │   └── VideoThumbnail.tsx  # 视频缩略图
│   ├── ai/                 # AI 功能组件
│   │   ├── ProcessingStatus.tsx # 处理状态显示
│   │   ├── AISettings.tsx      # AI 参数配置
│   │   └── ResultPreview.tsx   # 结果预览
│   └── ui/                 # 基础 UI 组件
└── hooks/
    ├── useVideoUpload.ts       # 视频上传 hook
    ├── useAIProcessing.ts      # AI 处理 hook
    └── useVideoPlayer.ts       # 视频播放器 hook
```

## 视频处理流程设计

### 视频上传与处理流程

```typescript
// hooks/useVideoUpload.ts
interface VideoUploadHook {
  upload: (file: File) => Promise<UploadResult>;
  progress: number;
  status: 'idle' | 'uploading' | 'processing' | 'completed' | 'error';
  error: string | null;
}

export const useVideoUpload = (): VideoUploadHook => {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState<VideoUploadHook['status']>('idle');
  const [error, setError] = useState<string | null>(null);

  const upload = async (file: File): Promise<UploadResult> => {
    try {
      setStatus('uploading');
      setError(null);

      // 1. 验证视频文件
      const validation = await validateVideoFile(file);
      if (!validation.valid) {
        throw new Error(validation.message);
      }

      // 2. 上传到存储服务
      const uploadResult = await uploadVideoFile(file, {
        onProgress: setProgress
      });

      setStatus('processing');

      // 3. 提取视频元数据
      const metadata = await extractVideoMetadata(uploadResult.url);

      // 4. 生成缩略图
      const thumbnail = await generateVideoThumbnail(uploadResult.url);

      setStatus('completed');

      return {
        ...uploadResult,
        metadata,
        thumbnail
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '上传失败';
      setError(errorMessage);
      setStatus('error');
      throw err;
    }
  };

  return { upload, progress, status, error };
};
```

### AI 视频处理核心

```typescript
// lib/ai/video-processor.ts

/**
 * AI 视频处理器核心类
 * 支持多种AI处理任务：增强、风格转换、内容分析等
 */
export class AIVideoProcessor {
  private processingQueue: ProcessingQueue;
  private modelManager: AIModelManager;

  constructor() {
    this.processingQueue = new ProcessingQueue();
    this.modelManager = new AIModelManager();
  }

  /**
   * 处理视频文件
   * @param videoUrl - 视频文件URL
   * @param options - 处理选项
   * @returns 处理结果
   */
  async processVideo(videoUrl: string, options: VideoProcessingOptions): Promise<ProcessingResult> {
    const taskId = generateTaskId();

    try {
      // 1. 添加到处理队列
      await this.processingQueue.add({
        id: taskId,
        videoUrl,
        options,
        status: 'queued',
        createdAt: new Date()
      });

      // 2. 根据处理类型选择合适的AI模型
      const model = await this.modelManager.loadModel(options.type);

      // 3. 执行AI处理
      const result = await this.executeProcessing(taskId, videoUrl, options, model);

      // 4. 后处理（如果需要）
      if (options.postProcessing) {
        await this.applyPostProcessing(result, options.postProcessing);
      }

      return result;
    } catch (error) {
      await this.processingQueue.updateStatus(taskId, 'failed', error.message);
      throw error;
    }
  }

  private async executeProcessing(
    taskId: string,
    videoUrl: string,
    options: VideoProcessingOptions,
    model: AIModel
  ): Promise<ProcessingResult> {
    // 具体的AI处理逻辑
    // 这里会根据不同的AI任务类型执行相应的处理

    switch (options.type) {
      case 'enhance':
        return await this.enhanceVideo(videoUrl, options, model);
      case 'style-transfer':
        return await this.styleTransfer(videoUrl, options, model);
      case 'content-analysis':
        return await this.analyzeContent(videoUrl, options, model);
      default:
        throw new Error(`不支持的处理类型: ${options.type}`);
    }
  }
}
```

## 组件设计模式

### 视频播放器组件

```typescript
// components/video/VideoPlayer.tsx
'use client';

interface VideoPlayerProps {
  src: string;
  poster?: string;
  metadata?: VideoMetadata;
  onLoadedMetadata?: (metadata: VideoMetadata) => void;
  onProgress?: (progress: number) => void;
  onError?: (error: Error) => void;
}

export const VideoPlayer = ({
  src,
  poster,
  metadata,
  onLoadedMetadata,
  onProgress,
  onError
}: VideoPlayerProps) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const { isPlaying, currentTime, duration, volume, play, pause, seek, setVolume } =
    useVideoPlayer(videoRef);

  // 视频加载完成处理
  const handleLoadedMetadata = useCallback(() => {
    if (videoRef.current && onLoadedMetadata) {
      const video = videoRef.current;
      const extractedMetadata: VideoMetadata = {
        duration: video.duration,
        videoWidth: video.videoWidth,
        videoHeight: video.videoHeight
        // ... 其他元数据
      };
      onLoadedMetadata(extractedMetadata);
    }
  }, [onLoadedMetadata]);

  // 播放进度更新
  const handleTimeUpdate = useCallback(() => {
    if (videoRef.current && onProgress) {
      const progress = (videoRef.current.currentTime / videoRef.current.duration) * 100;
      onProgress(progress);
    }
  }, [onProgress]);

  return (
    <div className='relative group bg-black rounded-lg overflow-hidden'>
      <video
        ref={videoRef}
        src={src}
        poster={poster}
        className='w-full h-full object-contain'
        onLoadedMetadata={handleLoadedMetadata}
        onTimeUpdate={handleTimeUpdate}
        onError={e => onError?.(new Error('视频加载失败'))}
      />

      {/* 自定义控制条 */}
      <VideoControls
        isPlaying={isPlaying}
        currentTime={currentTime}
        duration={duration}
        volume={volume}
        onPlay={play}
        onPause={pause}
        onSeek={seek}
        onVolumeChange={setVolume}
        className='absolute bottom-0 left-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity'
      />

      {/* 加载指示器 */}
      <LoadingSpinner className='absolute inset-0 flex items-center justify-center' />
    </div>
  );
};
```

## 性能优化策略

### 视频文件处理优化

```typescript
// lib/video/optimization.ts

/**
 * 视频文件优化配置
 */
export const VIDEO_OPTIMIZATION_CONFIG = {
  // 上传前压缩设置
  compression: {
    maxSize: 100 * 1024 * 1024, // 100MB
    quality: 0.8,
    maxWidth: 1920,
    maxHeight: 1080
  },

  // 支持的格式
  supportedFormats: ['mp4', 'webm', 'mov', 'avi'],

  // 缩略图生成
  thumbnail: {
    width: 320,
    height: 180,
    timePosition: 0.1 // 10% 位置截取
  }
};

/**
 * 视频文件预处理
 */
export const preprocessVideo = async (file: File): Promise<PreprocessResult> => {
  // 1. 文件格式验证
  const formatCheck = validateVideoFormat(file);
  if (!formatCheck.valid) {
    throw new Error(`不支持的视频格式: ${formatCheck.format}`);
  }

  // 2. 文件大小检查
  if (file.size > VIDEO_OPTIMIZATION_CONFIG.compression.maxSize) {
    // 执行压缩
    const compressedFile = await compressVideo(file, {
      quality: VIDEO_OPTIMIZATION_CONFIG.compression.quality,
      maxWidth: VIDEO_OPTIMIZATION_CONFIG.compression.maxWidth,
      maxHeight: VIDEO_OPTIMIZATION_CONFIG.compression.maxHeight
    });

    return { file: compressedFile, compressed: true };
  }

  return { file, compressed: false };
};
```

### AI 处理队列管理

```typescript
// lib/ai/processing-queue.ts

/**
 * AI 处理任务队列管理器
 * 实现任务排队、优先级处理、并发控制
 */
export class ProcessingQueue {
  private queue: ProcessingTask[] = [];
  private processing = new Map<string, ProcessingTask>();
  private maxConcurrent = 2; // 最大并发处理数

  /**
   * 添加处理任务
   */
  async add(task: ProcessingTask): Promise<void> {
    // 添加到队列
    this.queue.push({
      ...task,
      addedAt: new Date(),
      priority: this.calculatePriority(task)
    });

    // 按优先级排序
    this.queue.sort((a, b) => b.priority - a.priority);

    // 尝试处理下一个任务
    this.processNext();
  }

  /**
   * 处理下一个任务
   */
  private async processNext(): Promise<void> {
    // 检查是否达到最大并发数
    if (this.processing.size >= this.maxConcurrent) {
      return;
    }

    // 获取下一个待处理任务
    const nextTask = this.queue.shift();
    if (!nextTask) {
      return;
    }

    // 添加到处理中列表
    this.processing.set(nextTask.id, nextTask);

    try {
      // 执行任务处理
      await this.executeTask(nextTask);

      // 任务完成，从处理中移除
      this.processing.delete(nextTask.id);

      // 继续处理下一个任务
      this.processNext();
    } catch (error) {
      // 处理失败
      this.processing.delete(nextTask.id);
      await this.handleTaskError(nextTask, error);

      // 继续处理下一个任务
      this.processNext();
    }
  }

  /**
   * 计算任务优先级
   */
  private calculatePriority(task: ProcessingTask): number {
    let priority = 0;

    // 用户等级影响优先级
    if (task.userTier === 'premium') priority += 100;
    if (task.userTier === 'vip') priority += 200;

    // 文件大小影响优先级（小文件优先）
    priority -= Math.floor(task.fileSize / 1024 / 1024); // MB

    // 处理类型影响优先级
    const typeWeights = {
      thumbnail: 10,
      compress: 5,
      enhance: -5,
      'style-transfer': -10
    };
    priority += typeWeights[task.type] || 0;

    return priority;
  }
}
```

## 错误处理与监控

### 全局错误边界

```typescript
// components/ErrorBoundary.tsx

interface ErrorInfo {
  componentStack: string;
  errorBoundary?: string;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class VideoProcessingErrorBoundary extends Component<
  PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // 记录错误到监控系统
    this.logErrorToService(error, errorInfo);

    this.setState({
      error,
      errorInfo
    });
  }

  private logErrorToService(error: Error, errorInfo: ErrorInfo) {
    // 发送错误信息到监控服务
    console.error('视频处理错误:', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString()
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className='flex flex-col items-center justify-center min-h-[400px] p-8'>
          <div className='text-red-600 text-xl mb-4'>视频处理出现错误</div>
          <p className='text-gray-600 text-center mb-6'>
            抱歉，视频处理过程中出现了问题。请尝试刷新页面或联系技术支持。
          </p>
          <button
            className='bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700'
            onClick={() => window.location.reload()}
          >
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

这套规则文件涵盖了你的 AI Video 项目的各个方面，从总体架构到具体的代码实现细节，都体现了可读性第一、性能第二、恰到好处模块化的开发哲学。每个规则文件都可以独立使用，也可以组合使用来指导整个项目的开发工作。
